set define off
----------------------------------------------------------------------------------
--
-- Title: APX (APEX MAIN PACKAGE)
--
-- Description: PL/SQL Package to provide an interface to subprocedures and functions.
--
-- Parameters: None
--
-- Requirements: validated against Oracle 12c.
-- Lower versions are partly supported but it's not guaranteed to stay that way.
--
-- The User compiling this Package must have at least the following privileges:
--   RESOURCE and CONNECT Roles
--   APEX_ADMINISTRATOR_ROLE
--   select on "SYS"."V_$INSTANCE" and DBA_REGISTRY
--   create for views, tables, packages and synonyms
--
-- Example for User APXDBA:
--
--   GRANT "CONNECT" TO "APXDBA";
--   GRANT "RESOURCE" TO "APXDBA";
--   GRANT "APEX_ADMINISTRATOR_ROLE" TO "APXDBA";
--
--   GRANT SELECT ON "SYS"."V_$INSTANCE" TO "APXDBA";
--   GRANT SELECT ON "SYS"."DBA_REGISTRY" TO "APXDBA";
--
--   GRANT CREATE VIEW TO "APXDBA";
--   GRANT CREATE TABLE TO "APXDBA";
--   GRANT CREATE TRIGGER TO "APXDBA";
--   GRANT CREATE PROCEDURE TO "APXDBA";
--   GRANT CREATE PUBLIC SYNONYM TO "APXDBA";
--
--
-- History:      12.09.2007 SO: created
--               29.01.2017 SO: refactored for APEX
--               12.02.2017 SO: integrated in new Git Repository APX
--
-- Disclaimer: the software is delivered "as-is", and the author takes
-- no responsiblity nor guarantee for the proper function of this script
-- nor for any damages or misfunctions that might occure from using this software.
--
----------------------------------------------------------------------------------

------------------------------------------------------------------

-- Standard Procedures and Functions are defined in this Package
-- and used by APX Packages Scripts and other processes.
-- This Package is intended to run standalone and provide a hub
-- for all Sub Packages and Procedures.
--
-- Common Functions and Procedures are made public by creating
-- standalone Procedures and Functions that server as an interface
-- to those commeon objects.
--
-- This is planned to make Migration and Renaming easier, since you
-- just need to update the reference in the wrapper to make things
-- work again;-). To make sure these wrappers are in place, this
-- package checks them at startup (see init) und creates them as needed.
-- We keep basic logging and debugging Functions in here
-- to avoid the henn-egg problem of logging/debugging this package,
-- if its the only one in place (which it is in mimimal configuration:-)

------------------------------------------------------------------
--                          Package Specification
------------------------------------------------------------------
CREATE OR REPLACE PACKAGE "APX" AUTHID CURRENT_USER
IS

------------------------------------------------------------------
-- Global Variables, REF_CURSORS and Types
------------------------------------------------------------------

-- names of objects (tables, views... usually 30 bytes)
SUBTYPE objname IS ALL_OBJECTS.SUBOBJECT_NAME%TYPE;

-- generic weak REF CURSOR (no RETURN Clause)
TYPE curtype IS REF CURSOR;

-- status output
c_ok CONSTANT VARCHAR2(4) := 'OK.';
c_fld CONSTANT VARCHAR2(8) := 'failed!';
c_con CONSTANT VARCHAR2(8) := 'connected';
c_discon CONSTANT VARCHAR2(8) := 'disconnected';

-- padding
c_pad CONSTANT PLS_INTEGER := 85;

-- name of this package
l_pkg objname := 'APX';

-- step marker
l_stepname objname := 'null';
l_step pls_integer := 0;
l_step_comment varchar2(1000);
l_str varchar2(4000);
l_apxcon varchar2(100);

-- APEX Session
p_session_id varchar2(512);
p_app_id number;
p_ws_id number;
p_user_id number;

-- majorversion of current instance
db_version PLS_INTEGER;

-- majorversion of current APEX instance
apx_version PLS_INTEGER;

-- print_pretty_line counter
ppl_cnt PLS_INTEGER := 0;

-- print_pretty_line_length
ppl_len PLS_INTEGER := 0;

------------------------------------------------------------------
-- Package Procedures and Functions
------------------------------------------------------------------

------------------------------------------------------------------
-- DBMS_OUTPUT Limitations:
--
-- Oracle 9i:
--  Errors raised:
--  ORU-10027: buffer overflow, limit of <buf_limit> bytes.
--  ORU-10028:line length overflow, limit of 255 bytes

-- Oracle 10g:
--  Errors raised:
--  ORU-10027: buffer overflow, limit of <buf_limit> bytes.
--  ORU-10028:line length overflow, limit of 32767 bytes per line.

-- Note: Procedures assume LINESIZE 100 in SQL*Plus
------------------------------------------------------------------


------------------------------------------------------------------
-- PrintLine: Wrapper Procedure to DBMS_OUTPUT
-- avoids ORU-10028 Errors with lines larger 255 bytes (up until 9i)
-- adopted from Steven Feuerstein: PL/SQL Best Practices (B-01)
------------------------------------------------------------------
PROCEDURE "PL_PRINT_LINE" (
str_in IN VARCHAR2,
len_in IN INTEGER := 100,
expand_in IN BOOLEAN := TRUE);

------------------------------------------------------------------
-- PrintPrettyLine: Wrapper Procedure to DBMS_OUTPUT
-- see PrintLine for Description
-- added support for "pretty" line breaks at last blank of line.
------------------------------------------------------------------
PROCEDURE "PL_PRINT_PRETTY_LINE" (
str_in IN VARCHAR2,
len_in IN INTEGER := 100,
expand_in IN BOOLEAN := TRUE);

------------------------------------------------------------------
-- Wrapper Procedure to DBMS_OUTPUT for easier access
-- and extended functionality. Calls to pl and ppl are made from it.
------------------------------------------------------------------
PROCEDURE "PL_PRINT" (
str_in IN VARCHAR2,
len_in IN NUMBER DEFAULT 100,
p_line IN BOOLEAN DEFAULT TRUE, -- use put_line ?
c_padding IN NUMBER DEFAULT NULL, -- use rc_pad?
c_padchar IN CHAR DEFAULT '.',        -- character used for c_padding
print_pretty IN BOOLEAN := FALSE,  -- use PrintPretty for Linebreaks
expand_in IN BOOLEAN := TRUE);

------------------------------------------------------------------
-- Wrapper Procedures to HTP.PRN and HTP.PRINT for easier access
-- htp.print - a string terminated with a newline.
-- htp.prn - the specified string, not terminated with a newline.
-- Parameters: p_txt, p_date, p_int - the string to generate.
------------------------------------------------------------------

PROCEDURE "HT_PRINTN" (p_txt in varchar2);
PROCEDURE "HT_PRINTN" (p_date in date);
PROCEDURE "HT_PRINTN" (p_int in number);

PROCEDURE "HT_PRINT" (p_txt in varchar2);
PROCEDURE "HT_PRINT" (p_date in date);
PROCEDURE "HT_PRINT" (p_int in number);

------------------------------------------------------------------
-- Wrapper Procedures to HTP.PS and HTP.PRINTS for easier access
-- Both these subprograms generate a string and replace
-- the following characters with the corresponding escape sequence.
-- < to &lt;
-- > to &gt;
-- " to &quot;
-- & to &amp;
-- htp.prints an escaped string terminated with a newline.
-- htp.ps an escaped string not terminated with a newline.
-- Parameters: ctext - the string where to perform character substitution.
-- Generates: A string.
------------------------------------------------------------------

PROCEDURE "HT_PRINTS"(p_txt in varchar2);

PROCEDURE "HT_PS"(p_txt in varchar2);

------------------------------------------------------------------
-- Conversion Functions for special PL/SQL types
-- and extended functionality.
------------------------------------------------------------------

-- Conversion Functions for Booleans
FUNCTION "NUM_TO_BOOLEAN" (
  number_in IN NUMBER
, false_num IN NUMBER := 0 -- which value evaluates to false?
, operand IN VARCHAR2 := '>'
) RETURN BOOLEAN;

FUNCTION "BOOLEAN_TO_NUM" (
  boolean_in IN BOOLEAN
, true_num IN NUMBER := 1 -- which value is true?
) RETURN NUMBER;


END "APX";
/


------------------------------------------------------------------
--                          Package Body
------------------------------------------------------------------
CREATE OR REPLACE PACKAGE BODY "APX"
IS

------------------------------------------------------------------
-- Private Procedures and Functions
------------------------------------------------------------------


--------------------------------------------------------------------------------
-- Public Procedures and Functions
--------------------------------------------------------------------------------

------------------------------------------------------------------
-- Printing Output Procedures for Debug and Logging
------------------------------------------------------------------

-- print_line
PROCEDURE "PL_PRINT_LINE" (
str_in IN VARCHAR2,
len_in IN INTEGER := 100,
expand_in IN BOOLEAN := TRUE)
IS
len PLS_INTEGER;
str VARCHAR2(2000);
BEGIN
    -- set maximum chars/line
    IF (db_version < 10) THEN
        len  := LEAST (len_in, 255);
    ELSE
        len  := LEAST (len_in, 32767);
    END IF;

    IF (LENGTH (str_in) > len) THEN
        str := SUBSTR (str_in, 1, len);
        DBMS_OUTPUT.PUT_LINE (str);
        --recursive call of this procedure for remaining characters
        PL_PRINT_LINE (SUBSTR (str_in, len + 1), len, expand_in);
    ELSE
        str := str_in;
        DBMS_OUTPUT.PUT_LINE (str);
    END IF;
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE ('Execption in PL');
    IF expand_in THEN
       DBMS_OUTPUT.ENABLE (1000000);
    ELSE
       RAISE;
    END IF;
    DBMS_OUTPUT.PUT_LINE (str);
END;


-- print_pretty_line
PROCEDURE "PL_PRINT_PRETTY_LINE" (
str_in IN VARCHAR2,
len_in IN INTEGER := 100,
expand_in IN BOOLEAN := TRUE)
IS
len PLS_INTEGER := LEAST (len_in, 255);
str VARCHAR2(2000);
BEGIN
    -- set maximum chars/line
    IF (db_version < 10) THEN
        len  := LEAST (len_in, 255);
    ELSE
        len  := LEAST (len_in, 32767);
    END IF;

    IF (LENGTH (str_in) > len) THEN
        -- increment package variable ppl_cnt first
        ppl_cnt := ppl_cnt + 1;
        IF (ppl_cnt = 1) THEN -- first run, so set l_len
        -- len_in can change at runtime, so we need a constant value here.
            ppl_len := len_in;
        END IF;

        str := SUBSTR (str_in, 1, len);
        len := INSTR(str, ' ', -1, 1);
        str := SUBSTR (str, 1, INSTR(str, ' ', -1, 1));
        DBMS_OUTPUT.PUT_LINE (str);
        --recursive call of this procedure for remaining characters
        PL_PRINT_PRETTY_LINE (SUBSTR (str_in, len + 1), ppl_len, expand_in);
    ELSE
        str := str_in;
        DBMS_OUTPUT.PUT_LINE (str);
    END IF;
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE ('Execption in PPL');
    IF expand_in THEN
       DBMS_OUTPUT.ENABLE (1000000);
    ELSE
       RAISE;
    END IF;
    -- PUT_LINE Exceptions are handled in ppl or pl already
    DBMS_OUTPUT.PUT (str);
END;

-- PL/SQL Print
PROCEDURE "PL_PRINT" (
str_in IN VARCHAR2,
len_in IN NUMBER DEFAULT 100,
p_line IN BOOLEAN DEFAULT TRUE, -- use put_line ?
c_padding IN NUMBER DEFAULT NULL, -- use c_pad?
c_padchar IN CHAR DEFAULT '.',         -- character used for c_pad
print_pretty IN BOOLEAN := FALSE,  -- use PrintPretty for Linebreaks
expand_in IN BOOLEAN := TRUE)
IS
str VARCHAR2(2000);
max_line PLS_INTEGER;
BEGIN

    IF (c_padding IS NOT NULL) THEN
        str := RPAD(str_in, c_padding, c_padchar);
    ELSE
        str := str_in;
    END IF;

    IF (p_line) THEN
        IF (print_pretty) THEN
        --DBMS_OUTPUT.PUT_LINE ('Printing Pretty Line: '||str);
            PL_PRINT_PRETTY_LINE (str, len_in);
        ELSE
        --DBMS_OUTPUT.PUT_LINE ('Printing Line: '||str);
            PL_PRINT_LINE (str, len_in);
        END IF;
    ELSE
        DBMS_OUTPUT.PUT(str);
    END IF;
EXCEPTION WHEN OTHERS THEN
    IF expand_in THEN
       DBMS_OUTPUT.ENABLE (1000000);
    ELSE
       RAISE;
    END IF;
    -- PUT_LINE Exceptions are handled in pl_print_pretty_line or pl already
    DBMS_OUTPUT.PUT (str);
END;

------------------------------------------------------------------
-- Print Text Procedures (HTP.PRN and HTP.PRINT)
------------------------------------------------------------------

-- Print without newlines (classic print command)
PROCEDURE "HT_PRINT" (p_txt in varchar2)
is
  l_txt varchar2(4000);
begin
  l_txt := p_txt;
  htp.prn(l_txt);
end;

PROCEDURE "HT_PRINT" (p_date in date)
is
  l_date date;
begin
  l_date := p_date;
  htp.prn(l_date);
end;

PROCEDURE "HT_PRINT" (p_int in number)
is
  l_int number;
begin
  l_int := p_int;
  htp.prn(l_int);
end;

-- Print with newlines (classic printn command)
PROCEDURE "HT_PRINTN" (p_txt in varchar2)
is
  l_txt varchar2(4000);
begin
  l_txt := p_txt;
  htp.print(l_txt);
end;

PROCEDURE "HT_PRINTN" (p_date in date)
is
  l_date date;
begin
  l_date := p_date;
  htp.print(l_date);
end;

PROCEDURE "HT_PRINTN" (p_int in number)
is
  l_int number;
begin
  l_int := p_int;
  htp.print(l_int);
end;

------------------------------------------------------------------
-- Print Escaped Text Procedures (HTP.PS and HTP.PRINTS)
------------------------------------------------------------------

-- don't print newlines
PROCEDURE "HT_PS"(p_txt in varchar2)
is
  l_txt varchar2(4000);
begin
  l_txt := p_txt;
  htp.ps(l_txt);
end;

-- print newlines
PROCEDURE "HT_PRINTS" (p_txt in varchar2)
is
  l_txt varchar2(4000);
begin
  l_txt := p_txt;
  htp.prints(l_txt);
end;

------------------------------------------------------------------
-- Admin Functions (converters mostly)
------------------------------------------------------------------

-- convert number to a boolean
FUNCTION "NUM_TO_BOOLEAN" (
  number_in IN NUMBER
, false_num IN NUMBER := 0 -- which value evaluates to false?
, operand IN VARCHAR2 := '>'
) RETURN BOOLEAN
IS
retval BOOLEAN := FALSE;
BEGIN
    IF operand = '>' AND number_in > false_num THEN
        retval := TRUE;
    ELSIF operand = '=' AND number_in = false_num THEN
        retval := FALSE;
    ELSIF operand = '=' AND number_in != false_num THEN
        retval := TRUE;
    ELSIF operand = '<' AND number_in < false_num THEN
        retval := TRUE;
    END IF;
RETURN retval;
END;

-- convert boolean to a number
FUNCTION "BOOLEAN_TO_NUM" (
  boolean_in IN BOOLEAN
, true_num IN NUMBER := 1 -- which value is true?
) RETURN NUMBER
IS
retval NUMBER := 0;
BEGIN
    IF boolean_in THEN
        retval := true_num;
    END IF;
RETURN retval;
END;

------------------------------------------------------------------
-- Admin Procedures (DDL mostly)
------------------------------------------------------------------



------------------------------------------------------------------
-- Initialization Section
------------------------------------------------------------------
BEGIN
     l_stepname := 'INIT';
     l_step := l_step + 1;
     l_step_comment := 'APEX Session ID';

     ------------------------------------------------------------------
     -- APEX Environment
     -- (set here to see if a session exists,
     --  else no more processing needed.)
     ------------------------------------------------------------------
     p_session_id := nvl(v('SESSION_ID'), c_discon);

     if (p_session_id != c_discon) then
       ------------------------------------------------------------------
       -- APEX Settings (Workspace ID/NAME, APP_ID, APP_USER,...)
       ------------------------------------------------------------------



       ------------------------------------------------------------------
       -- get current Database- and APEX Majorversion
       -- (set in here once to minimize depencies among packages)
       ------------------------------------------------------------------
       begin
        l_step := l_step + 1;
        l_step_comment := 'DB Version';
        select substr(version, 1,2)
        into db_version
        from dba_registry
        where comp_id = ('CATALOG');

        l_step := l_step + 1;
        l_step_comment := 'APEX Version';
        select substr(version, 1,1)
        into apx_version
        from dba_registry
        where comp_id = ('APEX');

      -- in here we use hard-wired logging, since apxerr might not be in place yet
      exception when others then
        l_str := 'ERROR: ['|| l_pkg||']:['||l_stepname|| ']:[';
        l_str := l_str ||l_step||']: Setting '||l_step_comment||' has '||c_fld||' ***';
        dbms_output.put_line (l_str);
        dbms_output.put_line (sqlerrm);
      raise;
      end;

  else
    -- say something about usage of this package
    null;
  end if;



    -- Object Initialization ( objExists(:obj) ? return (1) : createObj(:obj) )
    -- static Object List as array (['p':'pl_print_pretty_line':'pl':'n2b':'b2n':'oe':'iu':'hr':'ia':'iv':(..)])
    --



------------------------------------------------------------------
-- End of Initialization Section
------------------------------------------------------------------

END "APX";
/

----------------------------------------------------------------------------------------------------
-- Display Errors if any
------------------------------------------------------------------
prompt Package "APX" Errors:
select line, text from all_errors
where name = 'APX'
order by line;
prompt Done compiling Package "APX" :-)
----------------------------------------------------------------------------------------------------
set define on

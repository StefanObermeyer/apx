    min-height: inherit;

border-style: inset;
border-color: initial;
border-image: initial;

.col-12 {
    width: 100%;
    min-height: 600px;
    }


    .t-Body-contentInner {
            padding-top: 3px;
      }

#R1808649679558818
#R1808649679558818 > div.t-Region-bodyWrap
#R1808649679558818 > div.t-Region-bodyWrap > div.t-Region-body { min-height: inherit; }
#R1808649679558818 div.t-Region-bodyWrap div.t-Region-body { min-height: inherit; }

home   fa-home
feedback fa-stack-exchange
bug-track fa-bug
project-track  fa-calendar
incident-management  fa-bomb

f?p=107:100:2647912187017::NO::P101_CURRENT_SESSION:12345:NO
f?p=1000:2:2647912187017:108:NO::P0_APP_REQUEST,P0_PAGE_ID:Incident%20Management,1

f?p=&REQUEST.:&P0_PAGE_ID.:&SESSION.::NO::P101_CURRENT_SESSION,P101_CURRENT_USER,P101_TO_PAGE:&SESSION.,&APP_USER.,1:NO

https%3A%2F%2Fol71%3A5505%2Fapex%2Fapex_authentication.callback%3Fp_session_id%3D2951039946583%26p_app_id%3D1000%26p_ajax_identifier%3DEEA7B7B5F4BCD0AD6E0741AC76F902C42E53F2391FC6D5335495002FA6121CD1

-- 109 P-Track ACL
select "ID", "USERNAME",
"ACCESS_LEVEL_ID",
case when ACCESS_LEVEL_ID = 3 then 'Administrator'
     when ACCESS_LEVEL_ID = 2 then 'Contributor'
     when ACCESS_LEVEL_ID = 1 then 'Reader'
     end the_access_level,
case when account_locked = 'Y' then 'Yes' else 'No' end account_locked,
lower(created_by) "CREATED_BY",
"CREATED"
from "#OWNER#"."EBA_PROJ_STATUS_USERS"

-- 108 Incident Management
select
  "ID",
  "USERNAME",
  "ACCESS_LEVEL_ID",
  case when account_locked = 'Y' then 'Yes' else 'No' end account_locked,
  "CREATED_BY",
  "CREATED"
from "#OWNER#"."EBA_INTRACK_USERS"  u;

-- LOGIN Page Process before header Sequence 20: APX APP SSO Login
begin
  apx.login(:P101_USERNAME);
end;


   --key_bytes_raw := SYS.DBMS_CRYPTO.RANDOMBYTES (num_key_bytes); 'ED00BF44C9E479232F41ED518FDD670F8DCE08623F38D1435C556122361F1AC5'
--    apx.setval('apx.g_key_bytes_raw', UTL_I18N.STRING_TO_RAW( '4CDD48541BE975B8D3EB3EE16C6152C755900DE9E59B0E57784ED10AA9A86868', 'AL32UTF8'));
--    key_bytes_raw := SUBSTR(DBMS_OBFUSCATION_TOOLKIT.DES3GetKey(1,  seed_string => 'BE975B8D3EB3EE16C6154CDD48541BE975B8D3EB3EE16C6152C755900DE9E59B0E57784ED10AA9A86868'), 1, 32) ;



(cast(current_timestamp as date) - date '1970-01-01')*24*60*60


-- Application User
CREATE TABLE  "APX$APP_USER_SESSION" (
	"APP_USER_SESSION_ID" NUMBER NOT NULL ENABLE,
	"APP_USERNAME" VARCHAR2(64) NOT NULL ENABLE,
	"APP_USER_EMAIL" VARCHAR2(64),
	"APP_ID" NUMBER,
	"APP_WS_ID" NUMBER,
	"APP_USER_PWD" VARCHAR2(64),
  "APP_USER_LAST_PAGE" NUMBER,
	"APP_USER_COOKIE_NAME" VARCHAR2(64),
	"APP_USER_LAST_LOGIN" TIMESTAMP (6) DEFAULT current_timestamp,
	"APP_USER_LAST_LOGOUT" TIMESTAMP (6) DEFAULT null,
	"APP_USER_SESSION_SECONDS" NUMBER DEFAULT 28800,
	"APP_USER_SESSION_IDLE_SEC" NUMBER DEFAULT 900, -- 15 min.
	 PRIMARY KEY ("APP_USER_SESSION_ID")
  USING INDEX  ENABLE
   )
/

CREATE INDEX  "APX$APPUSRSESS_LI" ON  "APX$APP_USER_SESSION" ("APP_USER_LAST_LOGIN")
/

CREATE INDEX  "APX$APPUSRSESS_LL" ON  "APX$APP_USER_SESSION" ("APP_USER_LAST_LOGOUT")
/

CREATE INDEX  "APX$APPUSRSESS_UQ" ON  "APX$APP_USER_SESSION" ("APP_USERNAME", "APP_ID")
/

CREATE INDEX  "APX$APPUSRSESS_LP" ON  "APX$APP_USER_SESSION" ("APP_USER_SESSION_ID", "APP_USER_LAST_PAGE")
/

CREATE INDEX  "APX$APPUSRSESS_PW" ON  "APX$APP_USER_SESSION" ("APP_USER_SESSION_ID", "APP_USER_PWD")
/


CREATE OR REPLACE EDITIONABLE TRIGGER  "APX$APP_USERSESS_BI_TRG"
before insert on "APX$APP_USER_SESSION"
referencing old as old new as new
for each row
begin
  if (:new.app_user_session_id is null) then
      select "APX$APP_USERSESS_SEQ".nextval
      into :new.app_user_session_id
      from dual;
  end if;
  select current_timestamp, nvl(v('APP_USER'), user)
  into :new.app_user_last_login, :new.app_username
  from dual;
end;
/
ALTER TRIGGER  "APX$APP_USERSESS_BI_TRG" ENABLE
/

-- register_login
insert into APX$APP_USER_SESSION (APP_USER_SESSION_ID,APP_USERNAME,APP_USER_EMAIL,APP_ID,APP_WS_ID,APP_USER_PWD)
values (v('SESSION'),v('P101_USERNAME'),v('APP_USER_EMAIL'),v('APP_ID'),apx.getwsid(v('APP_ID')), apx.encrypt(v(':P101_PASSWORD')));

-- apxssologin process before header in sso guest app (f.e. page 103)
declare
l_user apex_app_user_session.app_user_login%type;
begin
select app_user_login
into l_user
from apex_app_user_session
where app_user_session_id = :REQUEST;
apx.login(l_user);
exception when others then
null;
end;

--apx.redirect('f?p=1000:1001:'||:REQUEST||':LOAD_APP:'||:DEBUG||':::');

CREATE OR REPLACE FORCE EDITIONABLE VIEW "APEX_APP_USER_SESSION" (
"APP_USER_SESSION_ID", "APP_USER_LOGIN", "APP_USERNAME", "APP_USER_EMAIL",
"APP_ID", "APP_WS_ID", "APP_USER_LAST_LOGIN", "APP_USER_LAST_LOGOUT",
"APP_SESSION_DURATION_SECONDS", "APP_SESSION_REMAINING_SECONDS", "APP_SESSION_IS_CURRENT")
AS
  select app_user_session_id,
  nvl(app_username, app_user_email) app_user_login,
  app_username,
  app_user_email,
  app_id,
  app_ws_id,
  app_user_last_login,
  app_user_last_logout,
  trunc(app_session_duration) as app_session_duration_seconds,
  nvl(nullif(app_user_session_seconds,0), trunc(app_session_duration)) -
  trunc(app_session_duration) as app_session_remaining_seconds,
  case when app_session_duration <= app_user_session_seconds
          then 'Y'
          else 'N'
  end as app_session_is_current
from (
select app_user_session_id,
  app_username,
  app_user_email,
  app_id,
  app_ws_id,
  app_user_pwd,
  app_user_last_login,
  app_user_last_logout,
  app_user_session_seconds ,
  trunc((cast(current_timestamp as date) - date '1970-01-01')*24*60*60) as now,
  ((cast(app_user_last_login as date) - date '1970-01-01')*24*60*60) as login_second,
  trunc((cast(current_timestamp as date) - date '1970-01-01')*24*60*60) -
  ((cast(app_user_last_login as date) - date '1970-01-01')*24*60*60) as app_session_duration
from  "APX$APP_USER_SESSION"
)
/


CREATE OR REPLACE FORCE EDITIONABLE VIEW "APEX_CURRENT_SSO_SESSIONS" (
"APP_USER_LOGIN", "APP_ID", "APP_WS_ID", "SESSION_ID", "LATEST_LOGIN")
AS
  select app_user_login, app_id, app_ws_id,
 max(app_user_session_id) as session_id,
 max(app_user_last_login) as latest_login
 from apex_app_user_session
 where app_user_last_logout is null
 and app_session_is_current = 'Y'
 group by app_user_login, app_id, app_ws_id
/


--set item APX_SSO_MASTER on page 0 of master app to return apx.GET_SSO_MASTER


-- Set Link Function on Page 1001 before header
declare
L_sso_host varchar2(6) := :APP_ID;
l_session varchar2(1000);
l_app_id varchar2(1000);
l_app_to_go varchar2(10) := :P0_TO_APP;
l_url varchar2(32000);
l_sso_host_url varchar2(32000) := 'f?p='||l_sso_host||':LOGIN_DESKTOP:::'||:DEBUG||':::';
begin
-- check to see if there is a valid session for this user
select session_id, app_id
into l_session, l_app_id
from(
  select case when app_id = L_sso_host then 1 else 0 end seq, session_id, app_id
    from apex_current_sessions
    where app_id in (l_sso_host, l_app_to_go)
    and app_user_login = :APP_USER
order by 1
) where rownum = 1;

if l_app_to_go is not null then
  if l_app_id = l_sso_host  then
  -- we only a valid session in sso master app, so pass on to apxappsso login in other app
     l_url := 'f?p='||l_app_to_go||':APXSSO::'||l_session||':'||:DEBUG||':::';
  else -- we can pass on
     l_url := 'f?p='||l_app_to_go||':'||nvl(:P0_TO_PAGE, 'HOME')||':'||l_session||':'||:REQUEST||':'||:DEBUG||':::';
  end if;
else
  l_url := l_sso_host_url;
end if;
--return (l_url);
apx.redirect(l_url);
exception when no_data_found then
-- we have no session at all, so set login page in sso master app
l_url := l_sso_host_url;
--return l_url;
apx.redirect(l_url);
end;
/



declare
l_session number;
begin
  select app_user_session_id
  into l_session
  from apex_app_user_session
  where app_id = 1020
  and app_username = :APP_USER
  and app_user_last_login = (select max(app_user_last_login)
                             from apex_app_user_session
                              where app_id = 1020
                             and app_username = :APP_USER
                             and app_session_is_current = 'Y');
return l_session;
exception when no_data_found then
return null;
end;


-- Page 0 ITEM P0_TO_URL plsql code
declare
L_sso_host varchar2(6) := :APP_ID;
l_session varchar2(1000);
l_app_id varchar2(1000);
l_app_to_go varchar2(10) := :P0_TO_APP;
l_url varchar2(32000);
l_sso_host_url varchar2(32000) := 'f?p='||l_sso_host||':LOGIN_DESKTOP:::'||:DEBUG||':::';
begin
-- check to see if there is a valid session for this user
select session_id, app_id
into l_session, l_app_id
from(
  select case when app_id = L_sso_host then 1 else 0 end seq, session_id, app_id
    from apex_current_sessions
    where app_id in (l_sso_host, l_app_to_go)
    and app_user_login = :APP_USER
order by 1
) where rownum = 1;

if l_app_to_go is not null then
  if l_app_id = l_sso_host  then -- we only a valid session in sso master app,
                                 -- so pass on to login in other app
     l_url := 'f?p='||l_app_to_go||':APXSSO::'||l_session||':'||:DEBUG||':::';
  else -- we can pass on
     l_url := 'f?p='||l_app_to_go||':'||nvl(:P0_TO_PAGE, 'HOME')||':'||l_session||':'||:REQUEST||':'||:DEBUG||':::';
  end if;
else
  l_url := l_sso_host_url;
end if;
--:P0_TO_URL := l_url;
--apx.redirect('f?p='||l_sso_host||':1010:'||:SESSION||'::'||:DEBUG||':::');
return (l_url);
--apx.redirect(l_url);
exception when no_data_found then
-- we have no session at all, so set login page in sso master app
l_url := l_sso_host_url;
--:P0_TO_URL := l_url;
return l_url;
--apx.redirect('f?p='||l_sso_host||':1010:'||:SESSION||'::'||:DEBUG||':::');
end;




declare
l_session pls_integer := 0;
begin
select count(1) into l_session
from APEX_APP_USER_SESSION a
where a.app_user_session_id = :SESSION
  and a.app_username = :APP_USER
  and a.app_id = :APP_ID
  and a.app_ws_id = :FLOW_ID
  and a.app_session_is_current = 'Y';
--apex_authentication.is_authenticated
if l_Session >= 1 then
    return(apex_escape.html(:APP_USER)||', you are known to the system');
else
    return('Please sign in '|| l_session);
end if;
end;

-- has_Session?
create or replace function hs(
p_app_user varchar2 default null,
p_app_id number default null
) return boolean
is
begin
  return(apx.has_session( nvl(p_app_id, v('APP_ID')) , nvl(p_app_user, v('APP_USER')) ) );
end;
/

procedure login (
    p_on_success in varchar2 )
    is
begin
  if hs(:P101_CURRENT_USER) then
   sys.owa_util.redirect_url(p_on_success||'&p_x01='||:P101_TO_PAGE );
   apex_application.stop_apex_engine;
   else
     sys.owa_util.redirect_url('f?p='||:APP_ID||':101:::NO:::');
   apex_application.stop_apex_engine;
   end if;
end;

htp.p('has session');

declare
    l_callback varchar2(4000) := apex_authentication.get_callback_url;
    lval varchar2(4000);
begin
     lval := sys.utl_url.escape ( url => l_callback, escape_reserved_chars => true );
     return lval;
end;

-- SYS or APEX_050000
grant execute on apex_050000.wwv_flow_epg_include_mod_local to anonymous;

-- edit apex_050000.wwv_flow_epg_include_mod_local
-- comment in the first return statement to activate function
-- in the if-then-else block enter your procedure name in uppercase!

create or replace function apex_050000.wwv_flow_epg_include_mod_local(
    procedure_name in varchar2)
return boolean
is
begin
   -- return false; -- remove this statement when you modify this function
    --
    -- Administrator note: the procedure_name input parameter may be in the format:
    --
    --    procedure
    --    schema.procedure
    --    package.procedure
    --    schema.package.procedure
    --
    -- If the expected input parameter is a procedure name only, the IN list code shown below
    -- can be modified to itemize the expected procedure names. Otherwise you must parse the
    -- procedure_name parameter and replace the simple code below with code that will evaluate
    -- all of the cases listed above.
    --
    if upper(procedure_name) in (
           'APXDBA.REGISTER_LOGIN') then
        return TRUE;
    else
        return FALSE;
    end if;
end wwv_flow_epg_include_mod_local;





-- cards
#R1808519749558817 > div.t-Region-bodyWrap > div.t-Region-body > ul > li:nth-child(1) > div > a > div.t-Card-titleWrap > h3
#R1808519749558817 > div.t-Region-bodyWrap > div.t-Region-body > ul > li:nth-child(1)

#R1808519749558817 > div.t-Region-bodyWrap > div.t-Region-body > ul > li:nth-child(1)
#R1808519749558817 > div.t-Region-bodyWrap > div.t-Region-body > ul > li:nth-child(1)

https://ol71:5505/apex/f?p=1000:102:15297758448778:ADMIN:NO::P0_TO_PAGE:https%3A%2F%2Fol71%3A5505%2Fapex%2Fapex_authentication.callback%3Fp_session_id%3D14888594577106%26p_app_id%3D108%26p_ajax_identifier%3D:
f?p=1000:102:15297758448778:ADMIN:NO::P0_TO_PAGE:https%3A%2F%2Fol71%3A5505%2

---Feedback
https://ol71:5505/apex/f?p=107:1:13319874073819:::1:P1_CAME_FROM:100:

<button class="t-Button t-Button--icon   t-Button--iconRight t-Button--hot" onclick="popUpNamed('f?p=107:1:13319874073819:::1:P1_CAME_FROM:100:','SubmitFeedback');" type="button" id="B3342709940712714521"><span class="t-Icon t-Icon--left fa fa-chevron-right" aria-hidden="true"></span><span class="t-Button-label">Submit Feedback</span><span class="t-Icon t-Icon--right fa fa-chevron-right" aria-hidden="true"></span></button>

l_string   varchar2(32767) default p_string;



CREATE OR REPLACE PACKAGE BODY "EBA_FEEDBACK_FW" as
    function conv_txt_html (
        p_txt_message in varchar2 )
        return varchar2
    is
        l_html_message   varchar2(32767) default p_txt_message;
        l_temp_url varchar2(32767) := null;
        l_length number;
    begin
        l_html_message := replace(l_html_message, chr(10), '<br />');
        l_html_message := replace(l_html_message, chr(13), null);
        return l_html_message;
    end conv_txt_html;


    function conv_urls_links (
        p_string in varchar2 )
        return varchar2
    is
        l_string   varchar2(32767) default p_string;
        l_endofUrl varchar2(4000) default chr(10) || chr(13) || chr(9) || ' )<>';
        l_url         varchar2(4000);
        l_current_pos number := 1;
        n             number := 1;
        m             number := 1;
        p             number := 1;
    begin
        l_string := p_string || ' ';
        for i in 1 .. 1000 loop
            n := instr( lower(l_string), 'http://', l_current_pos );
            m := instr( lower(l_string), 'https://', l_current_pos );
            p := instr( lower(l_string), 'ftp://', l_current_pos   );
            -- set n to position of first link
            if m > 0 and (n = 0 or m < n) and (p = 0 or m < p) then
               n := m;
            elsif p > 0 and (n = 0 or p < n) then
               n := p;
            end if;
            exit when n = 0 or length(l_string) > 32000;
            for j in 0 .. length( l_string ) - n loop
                if ( instr( l_endofUrl, substr( l_string, n+j, 1 ) ) > 0 ) then
                   l_url := rtrim( substr( l_string, n, j ), '.'||chr(32)||chr(10) );
                   l_url := '<a href="' || l_url || '">' || l_url || '</a>';
                   l_string := substr( l_string, 1, n-1 ) || l_url || substr( l_string, n+j );
                   l_current_pos := n + length(l_url);
                   exit;
                end if;
            end loop;
        end loop;
        return l_string;
    end conv_urls_links;


    function tags_cleaner (
        p_tags  in varchar2,
        p_case  in varchar2 default 'U' )
        return varchar2
    is
        type tags is table of varchar2(255) index by varchar2(255);
        l_tags_a        tags;
        l_tag           varchar2(255);
        l_tags          apex_application_global.vc_arr2;
        l_tags_string   varchar2(32767);
        i               integer;
    begin
        l_tags := apex_util.string_to_table(p_tags,',');
        for i in 1..l_tags.count loop
            --remove all whitespace, including tabs, spaces, line feeds and carraige returns with a single space
            l_tag := substr(trim(regexp_replace(l_tags(i),'[[:space:]]{1,}',' ')),1,255);
            if l_tag is not null and l_tag != ' ' then
                if p_case = 'U' then
                    l_tag := upper(l_tag);
                elsif p_case = 'L' then
                    l_tag := lower(l_tag);
                end if;
                --add it to the associative array, if it is a duplicate, it will just be replaced
                l_tags_a(l_tag) := l_tag;
            end if;
        end loop;
        l_tag := null;
        l_tag := l_tags_a.first;
        while l_tag is not null loop
            l_tags_string := l_tags_string||l_tag;
            if l_tag != l_tags_a.last then
                l_tags_string := l_tags_string || ', ';
            end if;
            l_tag := l_tags_a.next(l_tag);
        end loop;
        return substr(l_tags_string, 1, 4000);
    end tags_cleaner;


    procedure tag_sync (
        p_new_tags          in varchar2,
        p_old_tags          in varchar2,
        p_content_type      in varchar2,
        p_content_id        in number )
    as
        type tags is table of varchar2(255) index by varchar2(255);
        l_new_tags_a    tags;
        l_old_tags_a    tags;
        l_new_tags      apex_application_global.vc_arr2;
        l_old_tags      apex_application_global.vc_arr2;
        l_merge_tags    apex_application_global.vc_arr2;
        l_dummy_tag     varchar2(255);
        i               integer;
    begin
        l_old_tags := apex_util.string_to_table(p_old_tags,', ');
        l_new_tags := apex_util.string_to_table(p_new_tags,', ');
        if l_old_tags.count > 0 then --do inserts and deletes
            --build the associative arrays
            for i in 1..l_old_tags.count loop
                l_old_tags_a(l_old_tags(i)) := l_old_tags(i);
            end loop;
            for i in 1..l_new_tags.count loop
                l_new_tags_a(l_new_tags(i)) := l_new_tags(i);
            end loop;
            --do the inserts
            for i in 1..l_new_tags.count loop
                begin
                    l_dummy_tag := l_old_tags_a(l_new_tags(i));
                exception when no_data_found then
                    insert into eba_feedback_tags (tag, content_id, content_type )
                    values (l_new_tags(i), p_content_id, p_content_type );
                    l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
                end;
            end loop;
            --do the deletes
            for i in 1..l_old_tags.count loop
                begin
                    l_dummy_tag := l_new_tags_a(l_old_tags(i));
                exception when no_data_found then
                    delete from eba_feedback_tags where content_id = p_content_id and tag = l_old_tags(i);
                    l_merge_tags(l_merge_tags.count + 1) := l_old_tags(i);
                end;
            end loop;
        else --just do inserts
            for i in 1..l_new_tags.count loop
                insert into eba_feedback_tags (tag, content_id, content_type )
                values (l_new_tags(i), p_content_id, p_content_type );
                l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
            end loop;
        end if;
        for i in 1..l_merge_tags.count loop
            merge into eba_feedback_tags_type_sum s
            using (select count(*) tag_count
                     from eba_feedback_tags
                    where tag = l_merge_tags(i) and content_type = p_content_type ) t
            on (s.tag = l_merge_tags(i) and s.content_type = p_content_type )
            when not matched then insert (tag, content_type, tag_count)
                                  values (l_merge_tags(i), p_content_type, t.tag_count)
            when matched then update set s.tag_count = t.tag_count;
            merge into eba_feedback_tags_sum s
            using (select sum(tag_count) tag_count
                     from eba_feedback_tags_type_sum
                    where tag = l_merge_tags(i) ) t
            on (s.tag = l_merge_tags(i) )
            when not matched then insert (tag, tag_count)
                                  values (l_merge_tags(i), t.tag_count)
            when matched then update set s.tag_count = t.tag_count;
        end loop;
    end tag_sync;


    function selective_escape (
        p_text  in varchar2,
        p_tags  in varchar2 default '<h2>,</h2>,<p>,</p>,<b>,</b>,<li>,</li>,<ul>,</ul>,<br />,<i>,</i>,<h3>,</h3>'
        ) return varchar2
    is
        t apex_application_global.vc_arr2;
        x varchar2(32767) := p_text;
    begin
        t := apex_util.string_to_table(p_tags, ',');
        for i in 1..t.count loop
            x := replace(x,t(i),'Aa'||i||'aA');
        end loop;
        x := apex_escape.html(x);
        for i in 1..t.count loop
            x := replace(x,'Aa'||i||'aA',t(i));
        end loop;
        return x;
    end selective_escape;


    function get_preference_value (
        p_preference_name varchar2 )
        return varchar2
    is
        l_preference_value varchar2(255);
    begin
        select preference_value
            into l_preference_value
        from eba_feedback_preferences
        where preference_name = p_preference_name;
        return l_preference_value;
    exception
        when no_data_found then
            return 'Preference does not exist';
    end get_preference_value;


    procedure set_preference_value (
        p_preference_name  varchar2,
        p_preference_value varchar2 )
    is
    begin
        merge into eba_feedback_preferences dest
        using ( select upper(p_preference_name) preference_name,
                    p_preference_value preference_value
                from dual ) src
        on ( upper(dest.preference_name) = src.preference_name )
        when matched then
            update set dest.preference_value = src.preference_value
        when not matched then
            insert (dest.preference_name, dest.preference_value)
            values (src.preference_name, src.preference_value);
    end set_preference_value;

    function compress_int (
        n in integer )
        return varchar2
    as
        ret varchar2(30);
        quotient integer;
        remainder integer;
        digit char(1);
    begin
        ret := '';
        quotient := n;
        while quotient > 0
        loop
            remainder := mod(quotient, 10 + 26);
            quotient := floor(quotient  / (10 + 26));
            if remainder < 26 then
                digit := chr(ascii('A') + remainder);
            else
                digit := chr(ascii('0') + remainder - 26);
            end if;
            ret := digit || ret;
        end loop ;
        if length(ret) < 5 then
            ret := lpad(ret, 4, 'A');
        end if ;
        return upper(ret);
    end compress_int;


    procedure add_error_log (
        p_error in apex_error.t_error )
    is
    pragma autonomous_transaction;
    begin
        -- Remove old errors
        delete from eba_feedback_errors where err_time <= localtimestamp - 21;
        -- Log the error.
        insert into eba_feedback_errors (
            app_id,
            app_page_id,
            app_user,
            user_agent,
            ip_address,
            ip_address2,
            message,
            page_item_name,
            region_id,
            column_alias,
            row_num,
            apex_error_code,
            ora_sqlcode,
            ora_sqlerrm,
            error_backtrace )
        select v('APP_ID'),
            v('APP_PAGE_ID'),
            v('APP_USER'),
            owa_util.get_cgi_env('HTTP_USER_AGENT'),
            owa_util.get_cgi_env('REMOTE_ADDR'),
            sys_context('USERENV', 'IP_ADDRESS'),
            substr(p_error.message,0,4000),
            p_error.page_item_name,
            p_error.region_id,
            p_error.column_alias,
            p_error.row_num,
            p_error.apex_error_code,
            p_error.ora_sqlcode,
            substr(p_error.ora_sqlerrm,0,4000),
            substr(p_error.error_backtrace,0,4000)
        from dual;
        commit;
    end add_error_log;


    function apex_error_handling (
        p_error in apex_error.t_error )
        return apex_error.t_error_result
    is
        l_result          apex_error.t_error_result;
        l_constraint_name varchar2(255);
    begin
        l_result := apex_error.init_error_result (
                        p_error => p_error );
        -- If it is an internal error raised by APEX, like an invalid statement or
        -- code which can not be executed, the error text might contain security sensitive
        -- information. To avoid this security problem we can rewrite the error to
        -- a generic error message and log the original error message for further
        -- investigation by the help desk.
        if p_error.is_internal_error then
            -- mask all errors that are not common runtime errors (Access Denied
            -- errors raised by application / page authorization and all errors
            -- regarding session and session state)
            if not p_error.is_common_runtime_error then
                add_error_log( p_error );
                -- Change the message to the generic error message which doesn't expose
                -- any sensitive information.
                l_result.message         := 'An unexpected internal application error has occurred.';
                l_result.additional_info := null;
            end if;
        else
            -- Always show the error as inline error
            -- Note: If you have created manual tabular forms (using the package
            --       apex_item/htmldb_item in the SQL statement) you should still
            --       use "On error page" on that pages to avoid loosing entered data
            l_result.display_location := case
                                           when l_result.display_location = apex_error.c_on_error_page then apex_error.c_inline_in_notification
                                           else l_result.display_location
                                         end;
            -- If it's a constraint violation like
            --
            --   -) ORA-00001: unique constraint violated
            --   -) ORA-02091: transaction rolled back (-> can hide a deferred constraint)
            --   -) ORA-02290: check constraint violated
            --   -) ORA-02291: integrity constraint violated - parent key not found
            --   -) ORA-02292: integrity constraint violated - child record found
            --
            -- we try to get a friendly error message from our constraint lookup configuration.
            -- If we don't find the constraint in our lookup table we fallback to
            -- the original ORA error message.
            if p_error.ora_sqlcode in (-1, -2091, -2290, -2291, -2292) then
                l_constraint_name := apex_error.extract_constraint_name (
                                         p_error => p_error );
                begin
                    select message
                      into l_result.message
                      from eba_feedback_error_lookup
                     where constraint_name = l_constraint_name;
                exception when no_data_found then null; -- not every constraint has to be in our lookup table
                end;
            end if;
            -- If an ORA error has been raised, for example a raise_application_error(-20xxx, '...')
            -- in a table trigger or in a PL/SQL package called by a process and we
            -- haven't found the error in our lookup table, then we just want to see
            -- the actual error text and not the full error stack with all the ORA error numbers.
            if p_error.ora_sqlcode is not null and l_result.message = p_error.message then
                l_result.message := apex_error.get_first_ora_error_text (
                                        p_error => p_error );
            end if;
            -- If no associated page item/tabular form column has been set, we can use
            -- apex_error.auto_set_associated_item to automatically guess the affected
            -- error field by examine the ORA error for constraint names or column names.
            if l_result.page_item_name is null and l_result.column_alias is null then
                apex_error.auto_set_associated_item (
                    p_error        => p_error,
                    p_error_result => l_result );
            end if;
        end if;
        return l_result;
    end apex_error_handling;


end eba_feedback_fw;
/
show errors


--Authentication Function Name

--Specify the name of the function that will verify the user's username and password,
--after they were entered on a login page. If you enter nothing, you allow any username/password to succeed.
--The function itself can be defined in the authentication's 'PL/SQL Code' textarea, within a package or as a stored function.

--This function must return a boolean to the login procedure that calls it.
--It has 2 input parameters 'p_username' and 'p_password' that can be used t
--o access the values an end user entered on the login page.

--Examples
--Enter the following code in the 'PL/SQL Code' textarea

function my_authentication (
    p_username in varchar2,
    p_password in varchar2 )
    return boolean
is
    l_user my_users.user_name%type := upper(p_username);
    l_pwd  my_users.password%type;
    l_id   my_users.id%type;
begin
    select id  , password
      into l_id, l_pwd
      from my_users
     where user_name = l_user;

    return l_pwd = rawtohex(sys.dbms_crypto.hash (
                       sys.utl_raw.cast_to_raw(p_password||l_id||l_user),
                       sys.dbms_crypto.hash_sh512 ));
exception
    when NO_DATA_FOUND then return false;
end;
and my_authentication as 'Authentication Function'.

-- Sentry Function
--Specify PL/SQL code returning a boolean value, within the 'PL/SQL Code' -

function sentry_basic_auth
return boolean
is
    c_auth_header   constant varchar2(4000) := owa_util.get_cgi_env('AUTHORIZATION');
    l_user_pass     varchar2(4000);
    l_separator_pos pls_integer;
begin
    if apex_application.g_user <> 'nobody' then
        return true;
    end if;

    if c_auth_header like 'Basic %' then
        l_user_pass := utl_encode.text_decode (
                           buf      => substr(c_auth_header, 7),
                           encoding => utl_encode.base64 );
        l_separator_pos := instr(l_user_pass, ':');
        if l_separator_pos > 0 then
            apex_authentication.login (
                p_username => substr(l_user_pass, 1, l_separator_pos-1),
                p_password => substr(l_user_pass, l_separator_pos+1) );
            return true;
        end if;
    end if;

    return false;
end sentry_basic_auth;


Specify a PL/SQL Database function -

sentry_basic_auth

P101_CURRENT_SESSION,P101_CURRENT_USER,P101_TO_PAGE:&SESSION.,&APP_USER.,1:NO
f?p=&REQUEST.:&P0_PAGE_ID.:&SESSION.::NO::P101_CURRENT_SESSION,P101_CURRENT_USER,P101_TO_PAGE:&SESSION.,&APP_USER.,1:NO


----
declare
l_usr varchar2(128);
l_pwd varchar2(256);
begin
  select s.app_username, apx.decrypt(s.app_user_pwd)
  into l_usr, l_pwd
  from apx$app_user_session s
  where lower(s.app_username) = lower(:P101_USERNAME)
    and exists
    (select 1 from apex_app_user_session u
      where u.app_username = s.app_username
      and u.app_session_is_current = 'Y')
   group by  s.app_username, apx.decrypt(s.app_user_pwd) ;
  -- Authenticate with User's Credentials
  apex_authentication.login(
    p_username => l_usr,
    p_password => l_pwd );
    exception when others then -- we anticipate a fresh login
    null;
end;
----




--FEATUREs
https://ol71:5505/apex/f?p=4800:9001:12361761471756::NO:9001::

declare
  l_callback varchar2(4000) := apex_authentication.get_callback_url;
  curl_back varchar2(4000);
  curl_togo varchar2(4000);
begin
  --curl_back := sys.utl_url.escape ( url => l_callback, escape_reserved_chars => true );
  curl_togo := 'f?p=1000:102:'||:P101_CURRENT_SESSION||':'||:P101_CURRENT_USER||':NO::P0_TO_PAGE:'||curl_back||':';
  sys.owa_util.redirect_url( curl_togo );
  apex_application.stop_apex_engine;
null;
end;


rawtohex(sys.dbms_crypto.hash (
                       sys.utl_raw.cast_to_raw(p_password||l_id||l_user),
                       sys.dbms_crypto.hash_sh512 ));


begin
if hs(:P101_CURRENT_USER) then
    sys.htp.p(:P101_CURRENT_USER||' is authenticated');
else
  sys.htp.p('Please sign in '||:P101_CURRENT_USER);
end if;
end;

declare
l_session pls_integer;
begin
select count(1) into l_session
from APEX_APP_USER_SESSION a
where a.app_user_session_id = :SESSION
  and a.app_username = :APP_USER
  and a.app_id = :APP_ID
  and a.app_ws_id = :FLOW_ID
  and a.app_session_is_current = 'Y';
--apex_authentication.is_authenticated
if l_Session = 1 then
    return(apex_escape.html(:APP_USER)||', you are known to the system');
else
    return('Please sign in');
end if;
end;


create or replace function encrypt (
input_string       VARCHAR2 :=  'Secret Message'
) return raw
is
   output_string      VARCHAR2 (200);
   encrypted_raw      RAW (2000);             -- stores encrypted binary text
   decrypted_raw      RAW (2000);             -- stores decrypted binary text
   num_key_bytes      NUMBER := 256/8;        -- key length 256 bits (32 bytes)
   key_bytes_raw      RAW (32);               -- stores 256-bit encryption key
   encryption_type    PLS_INTEGER :=          -- total encryption type
                            DBMS_CRYPTO.ENCRYPT_AES256
                          + DBMS_CRYPTO.CHAIN_CBC
                          + DBMS_CRYPTO.PAD_PKCS5;
BEGIN

   DBMS_OUTPUT.PUT_LINE ( 'Original string: ' || input_string);

   key_bytes_raw := DBMS_CRYPTO.RANDOMBYTES (num_key_bytes);
   encrypted_raw := DBMS_CRYPTO.ENCRYPT
      (
         src => UTL_I18N.STRING_TO_RAW (input_string,  'AL32UTF8'),
         typ => encryption_type,
         key => key_bytes_raw
      );
    -- The encrypted value "encrypted_raw" can be used here
       output_string := UTL_I18N.RAW_TO_CHAR (encrypted_raw, 'AL32UTF8');
       DBMS_OUTPUT.PUT_LINE ( 'Original string: ' || output_string);

return encrypted_raw;
end;
/

create or replace function decrypt (
p_encrypted_raw      RAW,
) return varchar2
is
   output_string      VARCHAR2 (200);
   decrypted_raw      RAW (2000);             -- stores decrypted binary text
   num_key_bytes      NUMBER := 256/8;        -- key length 256 bits (32 bytes)
   key_bytes_raw      RAW (32);               -- stores 256-bit encryption key
   encryption_type    PLS_INTEGER :=          -- total encryption type
                            DBMS_CRYPTO.ENCRYPT_AES256
                          + DBMS_CRYPTO.CHAIN_CBC
                          + DBMS_CRYPTO.PAD_PKCS5;
BEGIN

  output_string := UTL_I18N.RAW_TO_CHAR (p_encrypted_raw, 'AL32UTF8');
  DBMS_OUTPUT.PUT_LINE ( 'Input hash: ' || output_string);

  decrypted_raw := DBMS_CRYPTO.DECRYPT
  (
     src => p_encrypted_raw,
     typ => encryption_type,
     key => key_bytes_raw
  );

  output_string := UTL_I18N.RAW_TO_CHAR (decrypted_raw, 'AL32UTF8');
  DBMS_OUTPUT.PUT_LINE ('Decrypted string: ' || output_string);

return  output_string;
END;
/

#44664032728617983 > li > a

https://ol71:5505/apex/apx.logout?p_app_id=1000&p_session_id=26215704202147

https://ol71:5505/apex/apex_authentication.logout?p_app_id=1000&p_session_id=26215704202147


p_app_id     in number default null,
p_page_id    in number default null,
p_session_id in number default null,
p_request    in varchar2 default null,
p_debug      in varchar2 default 'NO',
p_args       in varchar2 default null,
p_vals       in varchar2 default null,

if p_app_id is not null then
  l_url := l_url ||':'||p_app_id;
end if;
if p_page_id is not null then
  l_url := l_url ||':'||p_page_id;
end if;
if p_session_id is not null then
  l_url := l_url ||':'||p_session_id;
end if;
if p_request is not null then
  l_url := l_url ||':'||p_request;
end if;
if p_debug is not null then
  l_url := l_url ||':'||p_debug;
end if;
if p_request is not null then
  l_url := l_url ||':'||p_request;
end if;


-- smaller breadcrumb
class="t-Body-title has-shadow t-Body-title-shrink"
